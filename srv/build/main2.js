
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { w as writable, S as SvelteComponentDev, i as init, n as not_equal, d as dispatch_dev, v as validate_slots, a as validate_each_argument, e as element, s as space, b as attr_dev, c as add_location, f as insert_dev, g as append_dev, h as add_render_callback, j as create_in_transition, k as create_out_transition, l as detach_dev, m as destroy_each, t as text, o as null_to_empty, p as toggle_class, q as set_data_dev, r as empty, u as transition_in, x as group_outros, y as transition_out, z as check_outros, A as safe_not_equal, N as Navaid, B as onDestroy, C as create_component, D as mount_component, E as destroy_component } from './vendor.js';

const navbarVisible = writable(true);

/* svelte\components\Navbar.svelte generated by Svelte v3.38.2 */
const file = "svelte\\components\\Navbar.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i].title;
	child_ctx[5] = list[i].href;
	child_ctx[6] = list[i].style;
	return child_ctx;
}

// (70:0) {#if visible}
function create_if_block(ctx) {
	let header;
	let nav;
	let a;
	let t1;
	let ul;
	let nav_intro;
	let nav_outro;
	let header_intro;
	let current;
	let each_value = /*links*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			header = element("header");
			nav = element("nav");
			a = element("a");
			a.textContent = "Essidon";
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(a, "class", "logo svelte-zjgve9");
			attr_dev(a, "href", "/");
			add_location(a, file, 72, 3, 1164);
			attr_dev(ul, "class", "svelte-zjgve9");
			add_location(ul, file, 75, 3, 1216);
			attr_dev(nav, "class", "svelte-zjgve9");
			add_location(nav, file, 71, 2, 1132);
			add_location(header, file, 70, 1, 1110);
		},
		m: function mount(target, anchor) {
			insert_dev(target, header, anchor);
			append_dev(header, nav);
			append_dev(nav, a);
			append_dev(nav, t1);
			append_dev(nav, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*links, active*/ 3) {
				each_value = /*links*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (nav_outro) nav_outro.end(1);
				if (!nav_intro) nav_intro = create_in_transition(nav, slide, {});
				nav_intro.start();
			});

			if (!header_intro) {
				add_render_callback(() => {
					header_intro = create_in_transition(header, squish, {});
					header_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			if (nav_intro) nav_intro.invalidate();
			nav_outro = create_out_transition(nav, slideOut, {});
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
			destroy_each(each_blocks, detaching);
			if (detaching && nav_outro) nav_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(70:0) {#if visible}",
		ctx
	});

	return block;
}

// (77:4) {#each links as {title, href, style}}
function create_each_block(ctx) {
	let li;
	let a;
	let t_value = /*title*/ ctx[4] + "";
	let t;
	let a_href_value;
	let a_class_value;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t = text(t_value);
			attr_dev(a, "href", a_href_value = /*href*/ ctx[5]);
			attr_dev(a, "class", a_class_value = "" + (null_to_empty(/*style*/ ctx[6]) + " svelte-zjgve9"));
			toggle_class(a, "active", /*active*/ ctx[0] == /*href*/ ctx[5]);
			add_location(a, file, 77, 9, 1274);
			attr_dev(li, "class", "svelte-zjgve9");
			add_location(li, file, 77, 5, 1270);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*links*/ 2 && t_value !== (t_value = /*title*/ ctx[4] + "")) set_data_dev(t, t_value);

			if (dirty & /*links*/ 2 && a_href_value !== (a_href_value = /*href*/ ctx[5])) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty & /*links*/ 2 && a_class_value !== (a_class_value = "" + (null_to_empty(/*style*/ ctx[6]) + " svelte-zjgve9"))) {
				attr_dev(a, "class", a_class_value);
			}

			if (dirty & /*links, active, links*/ 3) {
				toggle_class(a, "active", /*active*/ ctx[0] == /*href*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(77:4) {#each links as {title, href, style}}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*visible*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*visible*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*visible*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function squish(node, { duration = 150 }) {
	let rect = node.getBoundingClientRect();
	let height = rect.bottom - rect.top;

	return {
		duration,
		css: (t, u) => {
			return `
					height: ${t * height}px;
				`;
		}
	};
}

function slide(node, { duration = 150 }) {
	return {
		duration,
		css: (t, u) => {
			return `
					transform: translateY(-${u * 100}%);
				`;
		}
	};
}

function slideOut(node, { duration = 150 }) {
	return {
		duration,
		css: (t, u) => {
			return `
					position: absolute;
					transform: translateY(-${u * 100}%);
					left: 0;
					right: 0;
				`;
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Navbar", slots, []);
	let { active } = $$props;

	let { links = [
		{ title: "About", href: "/about" },
		{ title: "Contact", href: "/contact" },
		{
			title: "Login",
			href: "/login",
			style: "login"
		}
	] } = $$props;

	let visible;

	const unsubscribe = navbarVisible.subscribe(value => {
		$$invalidate(2, visible = value);
	});

	const writable_props = ["active", "links"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Navbar> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("links" in $$props) $$invalidate(1, links = $$props.links);
	};

	$$self.$capture_state = () => ({
		navbarVisible,
		active,
		links,
		visible,
		unsubscribe,
		squish,
		slide,
		slideOut
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("links" in $$props) $$invalidate(1, links = $$props.links);
		if ("visible" in $$props) $$invalidate(2, visible = $$props.visible);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [active, links, visible];
}

class Navbar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, not_equal, { active: 0, links: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Navbar",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*active*/ ctx[0] === undefined && !("active" in props)) {
			console.warn("<Navbar> was created without expected prop 'active'");
		}
	}

	get active() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get links() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set links(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* svelte\components\App.svelte generated by Svelte v3.38.2 */

function create_fragment(ctx) {
	let navbar;
	let t;
	let switch_instance;
	let switch_instance_anchor;
	let current;

	navbar = new Navbar({
			props: { active: /*active*/ ctx[2] },
			$$inline: true
		});

	var switch_value = /*Route*/ ctx[0];

	function switch_props(ctx) {
		return {
			props: { params: /*params*/ ctx[1] },
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			create_component(navbar.$$.fragment);
			t = space();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(navbar, target, anchor);
			insert_dev(target, t, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const navbar_changes = {};
			if (dirty & /*active*/ 4) navbar_changes.active = /*active*/ ctx[2];
			navbar.$set(navbar_changes);
			const switch_instance_changes = {};
			if (dirty & /*params*/ 2) switch_instance_changes.params = /*params*/ ctx[1];

			if (switch_value !== (switch_value = /*Route*/ ctx[0])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navbar.$$.fragment, local);
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navbar, detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("App", slots, []);
	let Route;
	let params = {};
	let active;
	let uri = location.pathname;

	function run(thunk, obj) {
		const target = uri;

		thunk.then(m => {
			if (target !== uri) {
				return;
			}

			$$invalidate(1, params = obj || null);

			if (m.preload) {
				m.preload({ params }).then(() => {
					if (target !== uri) {
						return;
					}

					$$invalidate(0, Route = m.default);
					window.scrollTo(0, 0);
				});
			} else {
				$$invalidate(0, Route = m.default);
				window.scrollTo(0, 0);
			}
		});
	}

	function track(obj) {
		$$invalidate(3, uri = obj.state || obj.uri || location.pathname);
	}

	addEventListener("replacestate", track);
	addEventListener("pushstate", track);
	addEventListener("popstate", track);
	const router = Navaid("/").on("/", () => run(import('./Home.js'))).on("/about", () => run(import('./About.js'))).on("/contact", () => run(import('./Contact.js'))).on("/login", () => run(import('./Login.js'))).listen();
	onDestroy(router.unlisten);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onDestroy,
		Navaid,
		Navbar,
		Route,
		params,
		active,
		uri,
		run,
		track,
		router
	});

	$$self.$inject_state = $$props => {
		if ("Route" in $$props) $$invalidate(0, Route = $$props.Route);
		if ("params" in $$props) $$invalidate(1, params = $$props.params);
		if ("active" in $$props) $$invalidate(2, active = $$props.active);
		if ("uri" in $$props) $$invalidate(3, uri = $$props.uri);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*uri*/ 8) {
			$$invalidate(2, active = uri || "/");
		}
	};

	return [Route, params, active, uri];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment.name
		});
	}
}

const app = new App({
	target: document.body
});

export { app as a, navbarVisible as n };
//# sourceMappingURL=main2.js.map
